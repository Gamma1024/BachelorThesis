---
title: "Copula GARCH Test"
author: "19-747-096 Jan Heinrich Schlegel"
date: "2022-07-31"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyverse)
library(magrittr)
library(yfR)
library(zoo)
library(psych)
library(tseries)
library(broom)
library(xts)
library(rugarch)
library(copula)
library(rmgarch)
library(parallel)
```

## Loading the data

```{r}
tickers <- c("KO", "XOM", "GE", "IBM", "CVX", "RTX", "PG", "CAT", "BA", "MRK")
stock_data <- yf_get(tickers, first_date = "2000-12-29", last_date = "2011-12-30", 
                     freq_data = "daily",  type_return = "log")
stock_data

# Only the first log return for each of the stocks is NA
# i.e. our actual log returns begin on the 1st of January 2001
sum(is.na(stock_data$ret_adjusted_prices))

for (ticker_nr in 1:10){
  assign(tickers[ticker_nr], stock_data %>% filter(ticker == tickers[ticker_nr]) %>% 
           select(ticker, ref_date, ret_adjusted_prices) %>% na.omit())
}
View(PG)

stocks.lret.df <- data.frame(Date = KO$ref_date, KO = KO$ret_adjusted_prices, XOM = XOM$ret_adjusted_prices, GE = GE$ret_adjusted_prices,
                        IBM = IBM$ret_adjusted_prices, CVX = CVX$ret_adjusted_prices, RTX = RTX$ret_adjusted_prices, PG = PG$ret_adjusted_prices,
                        CAT = CAT$ret_adjusted_prices, BA = BA$ret_adjusted_prices, MRK = MRK$ret_adjusted_prices)

stocks.lret.df

stocks.perclret.df <- data.frame(Date = KO$ref_date, apply(stocks.lret.df[,-1], 2, function(x)100*x))
stocks.perclret.df
```

## Creating Time Series Objects

```{r}
for (i in 1:10){
  name <- paste("ts", i, sep="_")
  assign(name, xts(stocks.perclret.df[,i+1], order.by = stocks.perclret.df$Date))
}

stocks.ts <- xts(stocks.perclret.df[,-1], order.by = stocks.perclret.df$Date)
stocks.ts

```

## AR(3)-NGARCH(1,1) to marginals
```{r}
set.seed(42)
numcores <- detectCores()

n.ahead <- 1
n <- length(stocks.ts)-n.ahead+1
meanModel <- list(armaOrder = c(3, 0))
varModel <- list(model = "fGARCH", submodel = "NGARCH", garchOrder = c(1,1))
uspec <- ugarchspec(varModel, mean.model = meanModel, distribution.model = "sstd")

# Fit marginal AR(3)-GARCH model
# fit <- apply(stocks.ts, 2, function(x)ugarchfit(uspec, data = x))
# eps <- sapply(fit, residuals, standardize = TRUE)
# nus <- sapply(fit, function(x)x@fit$coef[["shape"]])
# U <- pobs(eps)
# fitcop <- fitCopula(tCopula(dim = 10), data = U, method = "mpl")


cspec <- cgarchspec(uspec = multispec(replicate(10, uspec)), VAR = FALSE, dccOrder = c(1,1), distribution.model = list(copula = c("mvnorm"), method = "ML", time.varying = TRUE))
m <- 100000
n.window <- length(stocks.ts)-1000
VaR <- numeric(n.window)
cl <- makePSOCKcluster(numcores)
start_time <- Sys.time()
for (i in 1:n.window){
  end <- i+999
  stocks.window <- stocks.ts[i:end]
  cfit <- cgarchfit(cspec, stocks.window, cluster = cl)
  csim <- cgarchsim(cfit, n.sim = 1, n.start = 0, m.sim = m, startMethod = "unconditional", cluster = cl)
  port.dist <- apply(csim@msim$simZ, 3, mean)
  port.dist
  VaR[i] <- sort(port.dist)[0.05*m]
}
stopCluster(cl)
end_time <- Sys.time()
end_time-start_time
VaR
```

```{r}
VaR <- rep(VaR1, length(portfolio.plret.ts))
VaRplot(0.05, portfolio.plret.ts[-c(1:100)], VaR)
```

## Factor Returns
```{r}
FFCFactors.ts <- xts(FFCFactors.df[,-c(1,5)], order.by = FFFactors.df$Date)
FFCFactors.ts
set.seed(42)
numcores <- detectCores()

n.ahead <- 1
n <- length(stocks.perclret.df[,-1])-n.ahead+1
meanModel <- list(armaOrder = c(3, 0))
varModel <- list(model = "fGARCH", submodel = "NGARCH", garchOrder = c(1,1))
uspec <- ugarchspec(varModel, mean.model = meanModel, distribution.model = "sstd")

cspec <- cgarchspec(uspec = multispec(replicate(4, uspec)), VAR = FALSE, dccOrder = c(1,1), distribution.model = list(copula = c("mvnorm"), method = "ML", time.varying = TRUE))
m <- 100000
n.window <- 20#length(FFCFactors.df[,-1])-1000
VaR <- numeric(n.window)
cl <- makePSOCKcluster(numcores)
start_time <- Sys.time()
for (i in 1:n.window){
  end <- i+999
  factors.window <- FFCFactors.ts[i:end]
  cfit <- cgarchfit(cspec, factors.window, cluster = cl, fit.control=list(eval.se = FALSE))
  csim <- cgarchsim(cfit, n.sim = 1, n.start = 0, m.sim = m, startMethod = "unconditional", cluster = cl, solver = "solnp")
  port.dist <- apply(csim@msim$simZ, 3, mean)
  port.dist
  VaR[i] <- sort(port.dist)[0.05*m]
}
stopCluster(cl)
end_time <- Sys.time()
end_time-start_time
VaR


#### forgot reverse trafo of simulated values
```

```{r}
FFCFactors.ts <- xts(FFCFactors.df[,-c(1,5)], order.by = FFFactors.df$Date)
set.seed(42)
numcores <- detectCores()

n.ahead <- 1
n <- length(stocks.perclret.df[,-1])-n.ahead+1
meanModel <- list(armaOrder = c(3, 0))
varModel <- list(model = "fGARCH", submodel = "NGARCH", garchOrder = c(1,1))
uspec <- ugarchspec(varModel, mean.model = meanModel, distribution.model = "sstd")
mspec <- multispec(replicate(4, uspec))
dcc.spec <- dccspec(mspec, VAR = FALSE, model = "DCC", dccOrder = c(1,1), distribution =  "mvnorm")
cl <- makePSOCKcluster(numcores)
garch.dcc.fit <- dccfit(dcc.spec, data = FFCFactors.ts ,cluster = cl)
loglik.dcc <- garch.dcc.fit@mfit$log.likelihoods
AICdcc <- infocriteria(garch.dcc.fit)[1]
garch.dcc.fcst <- dccforecast(garch.dcc.fit, cluster = cl)
stopCluster(cl)
dcc.fcst.cov <- matrix(garch.dcc.fcst@mforecast$H[[1]], nrow = 4) # or rcov(garch.dcc.fcst)  
dcc.fcst.mu <- matrix(garch.dcc.fcst@mforecast$mu, nrow = 1)
garch.dcc.res <- garch.dcc.fit@mfit$stdresid
head(garch.dcc.res)
res1 <- garch.dcc.res[,1]
res2 <- garch.dcc.res[,2]
res3 <- garch.dcc.res[,3]
res4 <- garch.dcc.res[,4]
pobs.res <- apply(garch.dcc.res, 2, function(x)pobs(x))
par(mfrow = c(2,2))
for (i in 1:4)plot(garch.dcc.res[,i], type = "l")
cop.n <- fitCopula(normalCopula(dim = 4), data = pobs.res)
U.RN <- cCopula(pobs.res, cop.n@copula)
head(U.RN)
splom2(U.RN, cex = 0.2)
# calculate inverse to check for consistency:
U.N <- cCopula(U.RN, copula = cop.n@copula, inverse = TRUE)
all.equal(pobs.res, U.N)

# simulation:
cop.sim <- rCopula(100000, cop.n@copula)
dim(cop.sim)
plot(u)

res.sim <- cbind(qnorm(cop.sim[,1]), qnorm(cop.sim[,2]), qnorm(cop.sim[,3]), qnorm(cop.sim[,4]))
head(res.sim)
par(mfrow = c(2,2))
for (i in 1:4) plot(res.sim[1:100,i], type = "l")
# for qt: df = length(resx)-1

library(expm)
# use Chol if we want X'*X=A or X*X'=A; sqrtm if we want X*X = A
# returns are X_t = mu_t+sigma_t*epsilon_t
logret <- matrix(NA, nrow=100000, ncol=4) #nrow=nsim
sqrt.h <- sqrtm(dcc.fcst.cov)
sqrt.h
logret <- matrix(rep(dcc.fcst.mu, each = 100000), ncol = 4)+t(sqrt.h%*%t(res.sim))
plot(logret[1:50, 3], type = "l")
acumulated <- apply(logret, 2, cumsum)
acumulated
```

```{r}
# library(fPortfolio)
# x <- portfolioSpec()
# setType(x) <- "CVAR"
# setAlpha(x) <- 0.05
# setSolver(x) <- "solveRglpk.CVAR"
# rest <- c("minW[1:10]=-0.25","maxW[1:10]=0.25")
```

