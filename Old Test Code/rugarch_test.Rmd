---
title: "VaR& ES GARCH"
author: "19-747-096 Jan Heinrich Schlegel"
date: '2022-05-04'
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown
```{r}
library(tidyverse)
library(tsibble)
library(forecast)
library(rugarch)
library(zoo)
library(car)
library(tseries)
if (!require(psych)){install.packages("psych")}
if (!require(parallel)){install.packages("parallel")}
if (!require(xts)){install.packages("xts")}
if (!require(runner)){install.packages("runner")}
```


```{r}
esm <- EuStockMarkets 
tmp <- EuStockMarkets[,2] 
smi <- ts(tmp, start=start(esm), freq=frequency(esm))
plot(smi)
lret <- diff(log(smi))
plot(lret)
qqnorm(lret)
qqline(lret)
# Using car library:
qqPlot(lret)

jarque.bera.test(lret)
psych::describe(lret)

tsdisplay(lret, points=F)

# use makePSOCKcluster to run on several cores
cl <- makePSOCKcluster(8)
spec <- ugarchspec(variance.model = list(model = "eGARCH"), distribution.model = "norm")
rolling <- ugarchroll(spec, lret, n.start = 252, refit.every = 10, refit.window = "moving", cluster = cl, calculate.VaR = TRUE, VaR.alpha = c(0.01), keep.coef = TRUE, forecast.length = 10)
show(rolling)
stopCluster(cl)
```

```{r}
data(sp500ret)
cl = makePSOCKcluster(8)
spec = ugarchspec(variance.model = list(model = "eGARCH"),
                  distribution.model = "sstd")
roll = ugarchroll(spec, sp500ret, n.start = 1000, refit.every = 100,
                  refit.window = "moving", solver = "hybrid",
                  calculate.VaR = TRUE, VaR.alpha = c(0.01, 0.05),
                  cluster = cl, keep.coef = TRUE)
show(roll)
stopCluster(cl)
plot(roll, which = 4)
report(roll, type = "VaR")
```


```{r}
data("sp500ret")
cl = makePSOCKcluster(8)
spec = ugarchspec(variance.model = list(model = "sGARCH"),
                  distribution.model = "norm" ,mean.model =
                    list(armaOrder=c(1,0)))
roll = ugarchroll(spec, sp500_ret, n.start = 252, refit.every = 1,
                  n.ahead = 1, refit.window = "moving", solver = "hybrid",
                  calculate.VaR = FALSE, cluster = cl, keep.coef = TRUE)
stopCluster(cl)
#rollmean <- function(x, n = 253){stats::filter(x, rep(1/n, n), sides=1)}
#meansp500 <- rollmean(sp500ret) %>%
  #na.omit()

meansp500 <- rollapply(sp500_ts, width = 253, FUN = mean, align = "right") %>% 
  na.omit()
length(meansp500)
length(sp500ret[-c(1:252),1])
# meansp500 <- rolling_mean


plot(y=sp500ret[-c(1:252),1], x = 1:length(sp500ret[-c(1:252),1]), type  ="l")
lines(meansp500, col="red")

# show(roll)
dim(sp500ret)
str(sp500ret)
mean(sp500ret[,1])
# VaR <- mean(sp500ret[,1])+roll@forecast$density[,"Sigma"]*qnorm(p = 0.01, mean = 0, sd=1, lower.tail = TRUE)
VaR <- meansp500+roll@forecast$density[,"Sigma"]*qnorm(p = 0.01, mean = 0, sd=1, lower.tail = TRUE)
str(VaR)
length(VaR)

VaR_df <- data.frame(VaR = VaR, x = 1:length(VaR))
ret_df <- data.frame(ret = sp500ret[-c(1:252),1], x = 1:length(VaR))
plot(VaR, type = "l")
ggplot(VaR_df, aes(x = x, y = VaR))+
  geom_point(aes(x = x, y = ret_df$ret, color = as.factor(ret_df$ret<VaR)), size =1)+
  scale_color_manual(values = c("gray", "red"), name = "", labels = c("Lower than VaR", "Greater than VaR"))+
  labs(y = "Daily Returns SP500", x = "Observation", title = "Value at Risk comparison")+
  geom_line()+
  theme_classic()+
  theme(legend.position = c(.15, .9), legend.background = element_rect(color = NA), legend.key = element_rect(color = "transparent"))
  #theme(legend.position = "none")
sum(ret_df$ret < VaR)

## Testing
VaRTest(alpha = 0.01, actual = ret_df$ret, VaR = VaR, conf.level = 0.95)
```
```{r}
data("sp500ret")
dates <- as.Date(rownames(sp500ret))
sp500_ts <- xts(sp500ret, dates)
rolling_sd <- rollapply(sp500_ts, width = 253, FUN = sd, align = "right", fill = NA) %>% 
  na.omit()
length(rolling_sd)
rolling_mean <- rollapply(sp500_ts, width = 253, FUN = mean, align = "right") %>% 
  na.omit()

summary(rolling_sd)
summary(rolling_mean)
rolling <- data.frame(sd = rolling_sd, mean = rolling_mean, date = index(rolling_mean))
psych::describe(rolling)


VaR_constant <- rolling_mean+rolling_sd*qnorm(p = 0.01, mean = 0, sd=1, lower.tail = TRUE)
sum(ret_df$ret < VaR_constant)
```


```{r}
#ES <- mean(sp500ret[,1])-roll@forecast$density[,"Sigma"]*dnorm(qnorm(p = 0.01, mean = 0, sd=1, lower.tail = TRUE), mean = 0, sd = 1)/0.01
ES_df <- data.frame(ES = ES, x = 1:length(ES))
ret_df <- data.frame(ret = sp500ret[-c(1:1000),1], x = 1:length(ES))
plot(ES, type = "l")
ggplot(ES_df, aes(x = x, y = ES))+
  geom_point(aes(x = x, y = ret_df$ret, color = as.factor(ret_df$ret<ES)), size =1)+
  scale_color_manual(values = c("gray", "red"), name = "", labels = c("Lower than ES", "Greater than ES"))+
  labs(y = "Daily Returns SP500", x = "Observation", title = "Expected Shortfall comparison")+
  geom_line()+
  geom_line(aes(x = x, y = VaR_df$VaR), color="green")+
  theme_classic()+
  theme(legend.position = c(.15, .9), legend.background = element_rect(color = NA), legend.key = element_rect(color = "transparent"))
sum(ret_df$ret<ES)

## Testing
ESTest(alpha = 0.01, actual = ret_df$ret, ES = ES, VaR = VaR, conf.level = 0.95)
# H_0 rejected --> conditional shortfall is systematically underestimated
library(esback)
esr_backtest(sp500ret[-c(1:1000),1], VaR, ES, alpha = 0.01, version = 1, B = 0)
```
```{r}
data("sp500ret")
perc_ret <- sp500ret*100
cl <- makePSOCKcluster(8)
spec <- ugarchspec(variance.model = list(model = "eGARCH"), distribution.model = "std")
roll_VaR <- ugarchroll(spec, perc_ret, n.start = 1000, refit.every = 50,
                  refit.window = "moving", solver = "hybrid",
                  calculate.VaR = TRUE, VaR.alpha = c(0.01, 0.05),
                  cluster = cl, keep.coef = TRUE)
stopCluster(cl)
plot(roll_VaR, which = 4)
report(roll_VaR, type = "VaR")
# spec <- ugarchspec(variance.model = list(model = "fGARCH), submodel = list("TGARCH"))
```


```{r}

rugarch_VaR <- roll_VaR@forecast$VaR[,1] # for alpha(1%); 2nd column for alpha(5%)
nu <- roll_VaR@forecast$density[,"Shape"]
#VaR_t_quantile <- qnorm(0.01, 0, 1, lower.tail = TRUE)
VaR_t_quantile <- sqrt((nu-2)/nu) * qt(0.01, df = nu, lower.tail = TRUE)
VaR_calculated <- roll_VaR@forecast$density[,"Mu"]+roll_VaR@forecast$density[,"Sigma"]*VaR_t_quantile
rugarch_dist_VaR <- rugarch::qdist("std", 0.01, mu = roll_VaR@forecast$density[,"Mu"], sigma = roll_VaR@forecast$density[,"Sigma"], shape = roll_VaR@forecast$density[,"Shape"])




f = function(x, shape)rugarch::qdist("std", p=x, mu = 0, sigma = 1, shape = shape)
df1_var <- as.data.frame(roll_VaR, which = "density")
head(df_VaR)
ES_calculated <- df1_var['Mu'] + df1_var['Sigma']*apply(df1_var, 1, function(x) 
  integrate(f,0,0.01, shape = x['Shape'])$value/0.01)

ES_calculated <- unlist(ES_calculated)
# Insert Date for x
ES_df <- data.frame(ES = ES_calculated, x = 1:length(ES_calculated))
VaR_df <- data.frame(VaR = VaR_calculated, x = 1:length(VaR_calculated))
ret_df <- data.frame(ret = 100*sp500ret[-c(1:1000),1], x = 1:length(ES_calculated))
plot(ES_calculated, type = "l")
ggplot(ES_df, aes(x = x, y = ES_calculated))+
  geom_point(aes(x = x, y = ret_df$ret, color = as.factor(ret_df$ret<ES_calculated)), size =1)+
  scale_color_manual(values = c("gray", "red"), name = "", labels = c("Lower than ES", "Greater than ES"))+
  labs(y = "Daily Returns SP500", x = "Observation", title = "Expected Shortfall comparison")+
  geom_line(data=ES_df, aes(x=x, y=ES_calculated), color = "black", lty=1)+
  #geom_line(aes(x = x, y = VaR_df$VaR), color = "green", lty=1)+
  #scale_linetype_manual(name = "",values = c(1,1), labels = c("ES", "VaR"))+
  theme_classic()+
  theme(legend.position = c(.15, .9), legend.background = element_rect(color = NA), legend.key = element_rect(color = "transparent"))
sum(ret_df$ret<ES_calculated)


all.equal(as.numeric(rugarch_VaR), as.numeric(VaR_calculated))
df <- data.frame(rugarch = rugarch_VaR, calculated = VaR_calculated, rugarch_dist = rugarch_dist)
head(df)

summary(roll_VaR@forecast$density[,"Mu"])

# VaRTest(alpha = 0.01, actual = ret_df$ret, VaR = VaR_calculated, conf.level = 0.95)
# VaRTest(alpha = 0.01, actual = ret_df$ret, VaR = rugarch_VaR, conf.level = 0.95)
```

```{r}
library(quantmod)
library(tidyverse)
start_date <- as.Date("2000-01-01")
end_date <- as.Date("2021-12-31")
getSymbols("^SSMI", src ="yahoo", return.class = "xts", periodicity = "daily", from  = start_date, to = end_date)
View(SSMI)
sum(is.na(SSMI[,"SSMI.Close"]))
SMI <- SSMI[,"SSMI.Adjusted"]
which(is.na(SMI))
sum(is.na(SMI))
SMI_lret <- diff(log(SMI)) %>% 
  na.omit()
head(SMI_lret)
sum(is.na(SMI_lret))
View(SMI[is.na(SMI)])
# analyse NAs: all holidays?
all.equal(as.numeric(SSMI[,"SSMI.Adjusted"]), as.numeric(SSMI[,"SSMI.Close"])) # smi adjusted and closed are the same
plot(SMI_lret, type="h")
```
```{r}
data(sp500ret)
cl = makePSOCKcluster(8)
perc_ret <- sp500ret*100
spec = ugarchspec(variance.model = list(model = "eGARCH"),
                  distribution.model = "sstd")
roll = ugarchroll(spec, perc_ret, n.start = 1000, refit.every = 100,
                  refit.window = "moving", solver = "hybrid",
                  calculate.VaR = TRUE, VaR.alpha = c(0.01, 0.05),
                  cluster = cl, keep.coef = TRUE)
show(roll)
stopCluster(cl)
plot(roll, which = 4)
report(roll, type = "VaR")

cl <- makePSOCKcluster(8)
spec_gjr = ugarchspec(variance.model = list(model = "gjrGARCH"),
                  distribution.model = "sstd")
roll_gjr = ugarchroll(spec_gjr, perc_ret, n.start = 1000, refit.every = 100,
                  refit.window = "moving", solver = "hybrid",
                  calculate.VaR = TRUE, VaR.alpha = 0.05,
                  cluster = cl, keep.coef = TRUE)
show(roll_gjr)
stopCluster(cl)
plot(roll_gjr, which = 4)
report(roll_gjr, type = "VaR")

library("stargazer")
stargazer(roll_gjr@forecast$VaR)

cl <- makePSOCKcluster(8)
gjr_fit <- ugarchfit(spec_gjr, data = perc_ret, out.sample = 1000)
stopCluster(cl)
show(gjr_fit)
gjr_forecast <- ugarchforecast(gjr_fit, data=perc_ret, n.head=1, n.roll = 1000)
VaR_gjr <- as.numeric(quantile(gjr_fit, probs = 0.05))
plot(VaR_gjr)
all.equal(VaR_gjr, roll_gjr@forecast$VaR[,1])
```

